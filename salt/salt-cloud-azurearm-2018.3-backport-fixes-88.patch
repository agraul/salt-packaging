From 1b34cf85d2be6f1c7439fe5c18dc33e25eba38a9 Mon Sep 17 00:00:00 2001
From: jgleissner <jgleissner@suse.com>
Date: Wed, 25 Jul 2018 13:09:42 +0200
Subject: [PATCH] salt-cloud: AzureARM 2018.3 backport fixes (#88)

Modified salt/utils/cloud.py to work with previous versions of some utils modules,
as replacing them with 2018.3 versions causes breakage.
Removed salt/utils/crypt.py (added by previous backport commit)
Removed salt/utils/yaml.py (added by previous backport commit)
Reverted salt/utils/yamldumper.py and salt/utils/yamlloader.py to pre-backport
versions.
---
 salt/utils/cloud.py      |  14 ++--
 salt/utils/crypt.py      | 140 ---------------------------------------
 salt/utils/files.py      |   1 -
 salt/utils/yaml.py       |  10 ---
 salt/utils/yamldumper.py |  74 +--------------------
 salt/utils/yamlloader.py |  79 ++++++----------------
 6 files changed, 29 insertions(+), 289 deletions(-)
 delete mode 100644 salt/utils/crypt.py
 delete mode 100644 salt/utils/yaml.py

diff --git a/salt/utils/cloud.py b/salt/utils/cloud.py
index 07dbc49bed..6e68ad2f07 100644
--- a/salt/utils/cloud.py
+++ b/salt/utils/cloud.py
@@ -55,7 +55,6 @@ import salt.utils.platform
 import salt.utils.stringutils
 import salt.utils.versions
 import salt.utils.vt
-import salt.utils.yaml
 from salt.utils.nb_popen import NonBlockingPopen
 from salt.utils.validate.path import is_writeable
 
@@ -74,6 +73,7 @@ from salt.exceptions import (
 from salt.ext import six
 from salt.ext.six.moves import range  # pylint: disable=import-error,redefined-builtin,W0611
 from jinja2 import Template
+import yaml
 
 # Let's import pwd and catch the ImportError. We'll raise it if this is not
 # Windows. This import has to be below where we import salt.utils.platform!
@@ -292,7 +292,7 @@ def salt_config_to_yaml(configuration, line_break='\n'):
     '''
     Return a salt configuration dictionary, master or minion, as a yaml dump
     '''
-    return salt.utils.yaml.safe_dump(
+    return yaml.safe_dump(
         configuration,
         line_break=line_break,
         default_flow_style=False)
@@ -2517,7 +2517,7 @@ def cachedir_index_add(minion_id, profile, driver, provider, base=None):
     if os.path.exists(index_file):
         mode = 'rb' if six.PY3 else 'r'
         with salt.utils.files.fopen(index_file, mode) as fh_:
-            index = salt.utils.data.decode(msgpack.load(fh_, encoding=MSGPACK_ENCODING))
+            index = salt.utils.data.decode_dict(msgpack.load(fh_, encoding=MSGPACK_ENCODING))
     else:
         index = {}
 
@@ -2551,7 +2551,7 @@ def cachedir_index_del(minion_id, base=None):
     if os.path.exists(index_file):
         mode = 'rb' if six.PY3 else 'r'
         with salt.utils.files.fopen(index_file, mode) as fh_:
-            index = salt.utils.data.decode(msgpack.load(fh_, encoding=MSGPACK_ENCODING))
+            index = salt.utils.data.decode_dict(msgpack.load(fh_, encoding=MSGPACK_ENCODING))
     else:
         return
 
@@ -2650,7 +2650,7 @@ def change_minion_cachedir(
     path = os.path.join(base, cachedir, fname)
 
     with salt.utils.files.fopen(path, 'r') as fh_:
-        cache_data = salt.utils.data.decode(msgpack.load(fh_, encoding=MSGPACK_ENCODING))
+        cache_data = salt.utils.data.decode_dict(msgpack.load(fh_, encoding=MSGPACK_ENCODING))
 
     cache_data.update(data)
 
@@ -2729,7 +2729,7 @@ def list_cache_nodes_full(opts=None, provider=None, base=None):
                 minion_id = fname[:-2]  # strip '.p' from end of msgpack filename
                 mode = 'rb' if six.PY3 else 'r'
                 with salt.utils.files.fopen(fpath, mode) as fh_:
-                    minions[driver][prov][minion_id] = salt.utils.data.decode(msgpack.load(fh_, encoding=MSGPACK_ENCODING))
+                    minions[driver][prov][minion_id] = salt.utils.data.decode_dict(msgpack.load(fh_, encoding=MSGPACK_ENCODING))
 
     return minions
 
@@ -3007,7 +3007,7 @@ def diff_node_cache(prov_dir, node, new_data, opts):
 
     with salt.utils.files.fopen(path, 'r') as fh_:
         try:
-            cache_data = salt.utils.data.decode(msgpack.load(fh_, encoding=MSGPACK_ENCODING))
+            cache_data = salt.utils.data.decode_dict(msgpack.load(fh_, encoding=MSGPACK_ENCODING))
         except ValueError:
             log.warning('Cache for %s was corrupt: Deleting', node)
             cache_data = {}
diff --git a/salt/utils/crypt.py b/salt/utils/crypt.py
deleted file mode 100644
index 10b744044e..0000000000
--- a/salt/utils/crypt.py
+++ /dev/null
@@ -1,140 +0,0 @@
-# -*- coding: utf-8 -*-
-'''
-Functions dealing with encryption
-'''
-
-from __future__ import absolute_import, print_function, unicode_literals
-
-# Import Python libs
-import hashlib
-import logging
-import os
-
-log = logging.getLogger(__name__)
-
-# Import Salt libs
-import salt.loader
-import salt.utils.files
-from salt.exceptions import SaltInvocationError
-
-try:
-    import Crypto.Random
-    HAS_CRYPTO = True
-except ImportError:
-    HAS_CRYPTO = False
-
-
-def decrypt(data,
-            rend,
-            translate_newlines=False,
-            renderers=None,
-            opts=None,
-            valid_rend=None):
-    '''
-    .. versionadded:: 2017.7.0
-
-    Decrypt a data structure using the specified renderer. Written originally
-    as a common codebase to handle decryption of encrypted elements within
-    Pillar data, but should be flexible enough for other uses as well.
-
-    Returns the decrypted result, but any decryption renderer should be
-    recursively decrypting mutable types in-place, so any data structure passed
-    should be automagically decrypted using this function. Immutable types
-    obviously won't, so it's a good idea to check if ``data`` is hashable in
-    the calling function, and replace the original value with the decrypted
-    result if that is not the case. For an example of this, see
-    salt.pillar.Pillar.decrypt_pillar().
-
-    data
-        The data to be decrypted. This can be a string of ciphertext or a data
-        structure. If it is a data structure, the items in the data structure
-        will be recursively decrypted.
-
-    rend
-        The renderer used to decrypt
-
-    translate_newlines : False
-        If True, then the renderer will convert a literal backslash followed by
-        an 'n' into a newline before performing the decryption.
-
-    renderers
-        Optionally pass a loader instance containing loaded renderer functions.
-        If not passed, then the ``opts`` will be required and will be used to
-        invoke the loader to get the available renderers. Where possible,
-        renderers should be passed to avoid the overhead of loading them here.
-
-    opts
-        The master/minion configuration opts. Used only if renderers are not
-        passed.
-
-    valid_rend
-        A list containing valid renderers, used to restrict the renderers which
-        this function will be allowed to use. If not passed, no restriction
-        will be made.
-    '''
-    try:
-        if valid_rend and rend not in valid_rend:
-            raise SaltInvocationError(
-                '\'{0}\' is not a valid decryption renderer. Valid choices '
-                'are: {1}'.format(rend, ', '.join(valid_rend))
-            )
-    except TypeError as exc:
-        # SaltInvocationError inherits TypeError, so check for it first and
-        # raise if needed.
-        if isinstance(exc, SaltInvocationError):
-            raise
-        # 'valid' argument is not iterable
-        log.error('Non-iterable value %s passed for valid_rend', valid_rend)
-
-    if renderers is None:
-        if opts is None:
-            raise TypeError('opts are required')
-        renderers = salt.loader.render(opts, {})
-
-    rend_func = renderers.get(rend)
-    if rend_func is None:
-        raise SaltInvocationError(
-            'Decryption renderer \'{0}\' is not available'.format(rend)
-        )
-
-    return rend_func(data, translate_newlines=translate_newlines)
-
-
-def reinit_crypto():
-    '''
-    When a fork arises, pycrypto needs to reinit
-    From its doc::
-
-        Caveat: For the random number generator to work correctly,
-        you must call Random.atfork() in both the parent and
-        child processes after using os.fork()
-
-    '''
-    if HAS_CRYPTO:
-        Crypto.Random.atfork()
-
-
-def pem_finger(path=None, key=None, sum_type='sha256'):
-    '''
-    Pass in either a raw pem string, or the path on disk to the location of a
-    pem file, and the type of cryptographic hash to use. The default is SHA256.
-    The fingerprint of the pem will be returned.
-
-    If neither a key nor a path are passed in, a blank string will be returned.
-    '''
-    if not key:
-        if not os.path.isfile(path):
-            return ''
-
-        with salt.utils.files.fopen(path, 'rb') as fp_:
-            key = b''.join([x for x in fp_.readlines() if x.strip()][1:-1])
-
-    pre = getattr(hashlib, sum_type)(key).hexdigest()
-    finger = ''
-    for ind, _ in enumerate(pre):
-        if ind % 2:
-            # Is odd
-            finger += '{0}:'.format(pre[ind])
-        else:
-            finger += pre[ind]
-    return finger.rstrip(':')
diff --git a/salt/utils/files.py b/salt/utils/files.py
index 1068ba97ee..2e21d52218 100644
--- a/salt/utils/files.py
+++ b/salt/utils/files.py
@@ -19,7 +19,6 @@ import time
 import urllib
 
 # Import Salt libs
-import salt.utils.validate.path
 import salt.utils.platform
 import salt.utils.stringutils
 import salt.modules.selinux
diff --git a/salt/utils/yaml.py b/salt/utils/yaml.py
deleted file mode 100644
index 7fbfbe6035..0000000000
--- a/salt/utils/yaml.py
+++ /dev/null
@@ -1,10 +0,0 @@
-# -*- coding: utf-8 -*-
-'''
-Convenience module that provides our custom loader and dumper in a single module
-'''
-from __future__ import absolute_import, print_function, unicode_literals
-
-# pylint: disable=wildcard-import,unused-wildcard-import,unused-import
-from yaml import YAMLError, parser, scanner
-from salt.utils.yamldumper import *
-from salt.utils.yamlloader import *
diff --git a/salt/utils/yamldumper.py b/salt/utils/yamldumper.py
index ae43154bf2..8f8742cf14 100644
--- a/salt/utils/yamldumper.py
+++ b/salt/utils/yamldumper.py
@@ -7,7 +7,7 @@
 # pylint: disable=W0232
 #         class has no __init__ method
 
-from __future__ import absolute_import, print_function, unicode_literals
+from __future__ import absolute_import
 try:
     from yaml import CDumper as Dumper
     from yaml import CSafeDumper as SafeDumper
@@ -15,9 +15,6 @@ except ImportError:
     from yaml import Dumper
     from yaml import SafeDumper
 
-import yaml  # pylint: disable=blacklisted-import
-import collections
-
 from salt.utils.odict import OrderedDict
 
 try:
@@ -27,20 +24,6 @@ except ImportError:
     odict = None
     HAS_IOFLO = False
 
-__all__ = ['OrderedDumper', 'SafeOrderedDumper', 'IndentedSafeOrderedDumper',
-           'get_dumper', 'dump', 'safe_dump']
-
-
-class IndentMixin(Dumper):
-    '''
-    Mixin that improves YAML dumped list readability
-    by indenting them by two spaces,
-    instead of being flush with the key they are under.
-    '''
-
-    def increase_indent(self, flow=False, indentless=False):
-        return super(IndentMixin, self).increase_indent(flow, False)
-
 
 class OrderedDumper(Dumper):
     '''
@@ -54,14 +37,6 @@ class SafeOrderedDumper(SafeDumper):
     '''
 
 
-class IndentedSafeOrderedDumper(IndentMixin, SafeOrderedDumper):
-    '''
-    A YAML safe dumper that represents python OrderedDict as simple YAML map,
-    and also indents lists by two spaces.
-    '''
-    pass
-
-
 def represent_ordereddict(dumper, data):
     return dumper.represent_dict(list(data.items()))
 
@@ -69,53 +44,6 @@ def represent_ordereddict(dumper, data):
 OrderedDumper.add_representer(OrderedDict, represent_ordereddict)
 SafeOrderedDumper.add_representer(OrderedDict, represent_ordereddict)
 
-OrderedDumper.add_representer(
-    collections.defaultdict,
-    yaml.representer.SafeRepresenter.represent_dict
-)
-SafeOrderedDumper.add_representer(
-    collections.defaultdict,
-    yaml.representer.SafeRepresenter.represent_dict
-)
-
-OrderedDumper.add_representer(
-    'tag:yaml.org,2002:timestamp',
-    OrderedDumper.represent_scalar)
-SafeOrderedDumper.add_representer(
-    'tag:yaml.org,2002:timestamp',
-    SafeOrderedDumper.represent_scalar)
-
 if HAS_IOFLO:
     OrderedDumper.add_representer(odict, represent_ordereddict)
     SafeOrderedDumper.add_representer(odict, represent_ordereddict)
-
-
-def get_dumper(dumper_name):
-    return {
-        'OrderedDumper': OrderedDumper,
-        'SafeOrderedDumper': SafeOrderedDumper,
-        'IndentedSafeOrderedDumper': IndentedSafeOrderedDumper,
-    }.get(dumper_name)
-
-
-def dump(data, stream=None, **kwargs):
-    '''
-    .. versionadded:: 2018.3.0
-
-    Helper that wraps yaml.dump and ensures that we encode unicode strings
-    unless explicitly told not to.
-    '''
-    if 'allow_unicode' not in kwargs:
-        kwargs['allow_unicode'] = True
-    return yaml.dump(data, stream, **kwargs)
-
-
-def safe_dump(data, stream=None, **kwargs):
-    '''
-    Use a custom dumper to ensure that defaultdict and OrderedDict are
-    represented properly. Ensure that unicode strings are encoded unless
-    explicitly told not to.
-    '''
-    if 'allow_unicode' not in kwargs:
-        kwargs['allow_unicode'] = True
-    return yaml.dump(data, stream, Dumper=SafeOrderedDumper, **kwargs)
diff --git a/salt/utils/yamlloader.py b/salt/utils/yamlloader.py
index 16e30d1836..a51d1f1f25 100644
--- a/salt/utils/yamlloader.py
+++ b/salt/utils/yamlloader.py
@@ -1,14 +1,10 @@
 # -*- coding: utf-8 -*-
-'''
-Custom YAML loading in Salt
-'''
-
 # Import python libs
-from __future__ import absolute_import, print_function, unicode_literals
-import re
+from __future__ import absolute_import
 import warnings
 
-import yaml  # pylint: disable=blacklisted-import
+# Import third party libs
+import yaml
 from yaml.nodes import MappingNode, SequenceNode
 from yaml.constructor import ConstructorError
 try:
@@ -17,9 +13,11 @@ try:
 except Exception:
     pass
 
-import salt.utils.stringutils
-
-__all__ = ['SaltYamlSafeLoader', 'load', 'safe_load']
+# This function is safe and needs to stay as yaml.load. The load function
+# accepts a custom loader, and every time this function is used in Salt
+# the custom loader defined below is used. This should be altered though to
+# not require the custom loader to be explicitly added.
+load = yaml.load  # pylint: disable=C0103
 
 
 class DuplicateKeyWarning(RuntimeWarning):
@@ -38,24 +36,18 @@ class SaltYamlSafeLoader(yaml.SafeLoader, object):
     to make things like sls file more intuitive.
     '''
     def __init__(self, stream, dictclass=dict):
-        super(SaltYamlSafeLoader, self).__init__(stream)
+        yaml.SafeLoader.__init__(self, stream)
         if dictclass is not dict:
             # then assume ordered dict and use it for both !map and !omap
             self.add_constructor(
-                'tag:yaml.org,2002:map',
+                u'tag:yaml.org,2002:map',
                 type(self).construct_yaml_map)
             self.add_constructor(
-                'tag:yaml.org,2002:omap',
+                u'tag:yaml.org,2002:omap',
                 type(self).construct_yaml_map)
-        self.add_constructor(
-            'tag:yaml.org,2002:str',
-            type(self).construct_yaml_str)
-        self.add_constructor(
-            'tag:yaml.org,2002:python/unicode',
-            type(self).construct_unicode)
-        self.add_constructor(
-            'tag:yaml.org,2002:timestamp',
-            type(self).construct_scalar)
+            self.add_constructor(
+                u'tag:yaml.org,2002:python/unicode',
+                type(self).construct_unicode)
         self.dictclass = dictclass
 
     def construct_yaml_map(self, node):
@@ -80,25 +72,18 @@ class SaltYamlSafeLoader(yaml.SafeLoader, object):
 
         self.flatten_mapping(node)
 
-        context = 'while constructing a mapping'
         mapping = self.dictclass()
         for key_node, value_node in node.value:
             key = self.construct_object(key_node, deep=deep)
             try:
                 hash(key)
             except TypeError:
-                raise ConstructorError(
-                    context,
-                    node.start_mark,
-                    "found unacceptable key {0}".format(key_node.value),
-                    key_node.start_mark)
+                err = ('While constructing a mapping {0} found unacceptable '
+                       'key {1}').format(node.start_mark, key_node.start_mark)
+                raise ConstructorError(err)
             value = self.construct_object(value_node, deep=deep)
             if key in mapping:
-                raise ConstructorError(
-                    context,
-                    node.start_mark,
-                    "found conflicting ID '{0}'".format(key),
-                    key_node.start_mark)
+                raise ConstructorError('Conflicting ID \'{0}\''.format(key))
             mapping[key] = value
         return mapping
 
@@ -116,24 +101,15 @@ class SaltYamlSafeLoader(yaml.SafeLoader, object):
                 # an empty string. Change it to '0'.
                 if node.value == '':
                     node.value = '0'
-        elif node.tag == 'tag:yaml.org,2002:str':
-            # If any string comes in as a quoted unicode literal, eval it into
-            # the proper unicode string type.
-            if re.match(r'^u([\'"]).+\1$', node.value, flags=re.IGNORECASE):
-                node.value = eval(node.value, {}, {})  # pylint: disable=W0123
         return super(SaltYamlSafeLoader, self).construct_scalar(node)
 
-    def construct_yaml_str(self, node):
-        value = self.construct_scalar(node)
-        return salt.utils.stringutils.to_unicode(value)
-
     def flatten_mapping(self, node):
         merge = []
         index = 0
         while index < len(node.value):
             key_node, value_node = node.value[index]
 
-            if key_node.tag == 'tag:yaml.org,2002:merge':
+            if key_node.tag == u'tag:yaml.org,2002:merge':
                 del node.value[index]
                 if isinstance(value_node, MappingNode):
                     self.flatten_mapping(value_node)
@@ -156,8 +132,8 @@ class SaltYamlSafeLoader(yaml.SafeLoader, object):
                                            node.start_mark,
                                            "expected a mapping or list of mappings for merging, but found {0}".format(value_node.id),
                                            value_node.start_mark)
-            elif key_node.tag == 'tag:yaml.org,2002:value':
-                key_node.tag = 'tag:yaml.org,2002:str'
+            elif key_node.tag == u'tag:yaml.org,2002:value':
+                key_node.tag = u'tag:yaml.org,2002:str'
                 index += 1
             else:
                 index += 1
@@ -167,16 +143,3 @@ class SaltYamlSafeLoader(yaml.SafeLoader, object):
             mergeable_items = [x for x in merge if x[0].value not in existing_nodes]
 
             node.value = mergeable_items + node.value
-
-
-def load(stream, Loader=SaltYamlSafeLoader):
-    return yaml.load(stream, Loader=Loader)
-
-
-def safe_load(stream, Loader=SaltYamlSafeLoader):
-    '''
-    .. versionadded:: 2018.3.0
-
-    Helper function which automagically uses our custom loader.
-    '''
-    return yaml.load(stream, Loader=Loader)
-- 
2.17.1


