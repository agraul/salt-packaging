From b663de97c982bab05784f78f25db584ce57d0b1e Mon Sep 17 00:00:00 2001
From: Bo Maryniuk <bo@suse.de>
Date: Tue, 20 Nov 2018 16:06:31 +0100
Subject: [PATCH] Debian info_installed compatibility (#50453)

Remove unused variable

Get unit ticks installation time

Pass on unix ticks installation date time

Implement function to figure out package build time

Unify arch attribute

Add 'attr' support.

Use attr parameter in aptpkg

Add 'all_versions' output structure backward compatibility

Fix docstring

Add UT for generic test of function 'info'

Add UT for 'info' function with the parameter 'attr'

Add UT for info_installed's 'attr' param

Fix docstring

Add returned type check

Add UT for info_installed with 'all_versions=True' output structure

Refactor UT for 'owner' function

Refactor UT: move to decorators, add more checks

Schedule TODO for next refactoring of UT 'show' function

Refactor UT: get rid of old assertion way, flatten tests

Refactor UT: move to native assertions, cleanup noise, flatten complexity for better visibility what is tested

Lintfix: too many empty lines

Adjust architecture getter according to the lowpkg info

# Conflicts:
#	salt/modules/dpkg.py
#	tests/unit/modules/test_aptpkg.py
---
 salt/modules/aptpkg.py            |  20 +++-
 salt/modules/dpkg.py              |  91 ++++++++++++--
 tests/unit/modules/test_aptpkg.py | 189 +++++++++++++++++-------------
 tests/unit/modules/test_dpkg.py   |  69 +++++++++++
 4 files changed, 273 insertions(+), 96 deletions(-)

diff --git a/salt/modules/aptpkg.py b/salt/modules/aptpkg.py
index d7bd03627e..c54fd87424 100644
--- a/salt/modules/aptpkg.py
+++ b/salt/modules/aptpkg.py
@@ -2800,6 +2800,15 @@ def info_installed(*names, **kwargs):
 
         .. versionadded:: 2016.11.3
 
+    attr
+        Comma-separated package attributes. If no 'attr' is specified, all available attributes returned.
+
+        Valid attributes are:
+            version, vendor, release, build_date, build_date_time_t, install_date, install_date_time_t,
+            build_host, group, source_rpm, arch, epoch, size, license, signature, packager, url, summary, description.
+
+        .. versionadded:: Neon
+
     CLI example:
 
     .. code-block:: bash
@@ -2810,11 +2819,15 @@ def info_installed(*names, **kwargs):
     '''
     kwargs = salt.utils.args.clean_kwargs(**kwargs)
     failhard = kwargs.pop('failhard', True)
+    kwargs.pop('errors', None)                # Only for compatibility with RPM
+    attr = kwargs.pop('attr', None)           # Package attributes to return
+    all_versions = kwargs.pop('all_versions', False)  # This is for backward compatible structure only
+
     if kwargs:
         salt.utils.args.invalid_kwargs(kwargs)
 
     ret = dict()
-    for pkg_name, pkg_nfo in __salt__['lowpkg.info'](*names, failhard=failhard).items():
+    for pkg_name, pkg_nfo in __salt__['lowpkg.info'](*names, failhard=failhard, attr=attr).items():
         t_nfo = dict()
         # Translate dpkg-specific keys to a common structure
         for key, value in pkg_nfo.items():
@@ -2831,7 +2844,10 @@ def info_installed(*names, **kwargs):
             else:
                 t_nfo[key] = value
 
-        ret[pkg_name] = t_nfo
+        if all_versions:
+            ret.setdefault(pkg_name, []).append(t_nfo)
+        else:
+            ret[pkg_name] = t_nfo
 
     return ret
 
diff --git a/salt/modules/dpkg.py b/salt/modules/dpkg.py
index 03be5f821a..f736234ea4 100644
--- a/salt/modules/dpkg.py
+++ b/salt/modules/dpkg.py
@@ -252,6 +252,38 @@ def file_dict(*packages):
     return {'errors': errors, 'packages': ret}
 
 
+def _get_pkg_build_time(name):
+    '''
+    Get package build time, if possible.
+
+    :param name:
+    :return:
+    '''
+    iso_time = iso_time_t = None
+    changelog_dir = os.path.join('/usr/share/doc', name)
+    if os.path.exists(changelog_dir):
+        for fname in os.listdir(changelog_dir):
+            try:
+                iso_time_t = int(os.path.getmtime(os.path.join(changelog_dir, fname)))
+                iso_time = datetime.datetime.utcfromtimestamp(iso_time_t).isoformat() + 'Z'
+                break
+            except OSError:
+                pass
+
+    # Packager doesn't care about Debian standards, therefore Plan B: brute-force it.
+    if not iso_time:
+        for pkg_f_path in __salt__['cmd.run']('dpkg-query -L {}'.format(name)).splitlines():
+            if 'changelog' in pkg_f_path.lower() and os.path.exists(pkg_f_path):
+                try:
+                    iso_time_t = int(os.path.getmtime(pkg_f_path))
+                    iso_time = datetime.datetime.utcfromtimestamp(iso_time_t).isoformat() + 'Z'
+                    break
+                except OSError:
+                    pass
+
+    return iso_time, iso_time_t
+
+
 def _get_pkg_info(*packages, **kwargs):
     '''
     Return list of package information. If 'packages' parameter is empty,
@@ -274,7 +306,7 @@ def _get_pkg_info(*packages, **kwargs):
     ret = []
     cmd = "dpkg-query -W -f='package:" + bin_var + "\\n" \
           "revision:${binary:Revision}\\n" \
-          "architecture:${Architecture}\\n" \
+          "arch:${Architecture}\\n" \
           "maintainer:${Maintainer}\\n" \
           "summary:${Summary}\\n" \
           "source:${source:Package}\\n" \
@@ -307,9 +339,14 @@ def _get_pkg_info(*packages, **kwargs):
             key, value = pkg_info_line.split(":", 1)
             if value:
                 pkg_data[key] = value
-            install_date = _get_pkg_install_time(pkg_data.get('package'))
-            if install_date:
-                pkg_data['install_date'] = install_date
+        install_date, install_date_t = _get_pkg_install_time(pkg_data.get('package'), pkg_data.get('arch'))
+        if install_date:
+            pkg_data['install_date'] = install_date
+            pkg_data['install_date_time_t'] = install_date_t  # Unix ticks
+        build_date, build_date_t = _get_pkg_build_time(pkg_data.get('package'))
+        if build_date:
+            pkg_data['build_date'] = build_date
+            pkg_data['build_date_time_t'] = build_date_t
         pkg_data['description'] = pkg_descr.split(":", 1)[-1]
         ret.append(pkg_data)
 
@@ -341,13 +378,26 @@ def _get_pkg_install_time(pkg):
 
     :return:
     '''
-    iso_time = None
+    iso_time = iso_time_t = None
+    loc_root = '/var/lib/dpkg/info'
     if pkg is not None:
-        location = "/var/lib/dpkg/info/{0}.list".format(pkg)
-        if os.path.exists(location):
-            iso_time = datetime.datetime.utcfromtimestamp(int(os.path.getmtime(location))).isoformat() + "Z"
+        locations = []
+        if arch is not None and arch != 'all':
+            locations.append(os.path.join(loc_root, '{0}:{1}.list'.format(pkg, arch)))
+
+        locations.append(os.path.join(loc_root, '{0}.list'.format(pkg)))
+        for location in locations:
+            try:
+                iso_time_t = int(os.path.getmtime(location))
+                iso_time = datetime.datetime.utcfromtimestamp(iso_time_t).isoformat() + 'Z'
+                break
+            except OSError:
+                pass
 
-    return iso_time
+        if iso_time is None:
+            log.debug('Unable to get package installation time for package "%s".', pkg)
+
+    return iso_time, iso_time_t
 
 
 def _get_pkg_ds_avail():
@@ -397,6 +447,15 @@ def info(*packages, **kwargs):
 
         .. versionadded:: 2016.11.3
 
+    attr
+        Comma-separated package attributes. If no 'attr' is specified, all available attributes returned.
+
+        Valid attributes are:
+            version, vendor, release, build_date, build_date_time_t, install_date, install_date_time_t,
+            build_host, group, source_rpm, arch, epoch, size, license, signature, packager, url, summary, description.
+
+        .. versionadded:: Neon
+
     CLI example:
 
     .. code-block:: bash
@@ -411,6 +470,10 @@ def info(*packages, **kwargs):
 
     kwargs = salt.utils.args.clean_kwargs(**kwargs)
     failhard = kwargs.pop('failhard', True)
+    attr = kwargs.pop('attr', None) or None
+    if attr:
+        attr = attr.split(',')
+
     if kwargs:
         salt.utils.args.invalid_kwargs(kwargs)
 
@@ -430,6 +493,14 @@ def info(*packages, **kwargs):
         lic = _get_pkg_license(pkg['package'])
         if lic:
             pkg['license'] = lic
-        ret[pkg['package']] = pkg
+
+        # Remove keys that aren't in attrs
+        pkg_name = pkg['package']
+        if attr:
+            for k in list(pkg.keys())[:]:
+                if k not in attr:
+                    del pkg[k]
+
+        ret[pkg_name] = pkg
 
     return ret
diff --git a/tests/unit/modules/test_aptpkg.py b/tests/unit/modules/test_aptpkg.py
index c0e26cfcd4..5352e39982 100644
--- a/tests/unit/modules/test_aptpkg.py
+++ b/tests/unit/modules/test_aptpkg.py
@@ -13,12 +13,14 @@ import copy
 # Import Salt Testing Libs
 from tests.support.mixins import LoaderModuleMockMixin
 from tests.support.unit import TestCase, skipIf
-from tests.support.mock import MagicMock, patch, NO_MOCK, NO_MOCK_REASON
+from tests.support.mock import Mock, MagicMock, patch, NO_MOCK, NO_MOCK_REASON
 
 # Import Salt Libs
 from salt.ext import six
 from salt.exceptions import CommandExecutionError, SaltInvocationError
 import salt.modules.aptpkg as aptpkg
+import pytest
+import textwrap
 
 
 APT_KEY_LIST = r'''
@@ -142,51 +144,39 @@ class AptPkgTestCase(TestCase, LoaderModuleMockMixin):
     def setup_loader_modules(self):
         return {aptpkg: {}}
 
+    @patch('salt.modules.aptpkg.__salt__',
+           {'pkg_resource.version': MagicMock(return_value=LOWPKG_INFO['wget']['version'])})
     def test_version(self):
         '''
         Test - Returns a string representing the package version or an empty string if
         not installed.
         '''
-        version = LOWPKG_INFO['wget']['version']
-        mock = MagicMock(return_value=version)
-        with patch.dict(aptpkg.__salt__, {'pkg_resource.version': mock}):
-            self.assertEqual(aptpkg.version(*['wget']), version)
+        assert aptpkg.version(*['wget']) == aptpkg.__salt__['pkg_resource.version']()
 
+    @patch('salt.modules.aptpkg.latest_version', MagicMock(return_value=''))
     def test_upgrade_available(self):
         '''
         Test - Check whether or not an upgrade is available for a given package.
         '''
-        with patch('salt.modules.aptpkg.latest_version',
-                   MagicMock(return_value='')):
-            self.assertFalse(aptpkg.upgrade_available('wget'))
+        assert not aptpkg.upgrade_available('wget')
 
+    @patch('salt.modules.aptpkg.get_repo_keys', MagicMock(return_value=REPO_KEYS))
+    @patch('salt.modules.aptpkg.__salt__', {'cmd.run_all': MagicMock(return_value={'retcode': 0, 'stdout': 'OK'})})
     def test_add_repo_key(self):
         '''
         Test - Add a repo key.
         '''
-        with patch('salt.modules.aptpkg.get_repo_keys',
-                   MagicMock(return_value=REPO_KEYS)):
-            mock = MagicMock(return_value={
-                'retcode': 0,
-                'stdout': 'OK'
-            })
-            with patch.dict(aptpkg.__salt__, {'cmd.run_all': mock}):
-                self.assertTrue(aptpkg.add_repo_key(keyserver='keyserver.ubuntu.com',
-                                                    keyid='FBB75451'))
+        assert aptpkg.add_repo_key(keyserver='keyserver.ubuntu.com', keyid='FBB75451')
 
+    @patch('salt.modules.aptpkg.get_repo_keys', MagicMock(return_value=REPO_KEYS))
+    @patch('salt.modules.aptpkg.__salt__', {'cmd.run_all': MagicMock(return_value={'retcode': 0, 'stdout': 'OK'})})
     def test_add_repo_key_failed(self):
         '''
         Test - Add a repo key using incomplete input data.
         '''
-        with patch('salt.modules.aptpkg.get_repo_keys',
-                   MagicMock(return_value=REPO_KEYS)):
-            kwargs = {'keyserver': 'keyserver.ubuntu.com'}
-            mock = MagicMock(return_value={
-                'retcode': 0,
-                'stdout': 'OK'
-            })
-            with patch.dict(aptpkg.__salt__, {'cmd.run_all': mock}):
-                self.assertRaises(SaltInvocationError, aptpkg.add_repo_key, **kwargs)
+        with pytest.raises(SaltInvocationError) as ex:
+            aptpkg.add_repo_key(keyserver='keyserver.ubuntu.com')
+        assert ' No keyid or keyid too short for keyserver: keyserver.ubuntu.com' in str(ex)
 
     def test_get_repo_keys(self):
         '''
@@ -199,35 +189,31 @@ class AptPkgTestCase(TestCase, LoaderModuleMockMixin):
         with patch.dict(aptpkg.__salt__, {'cmd.run_all': mock}):
             self.assertEqual(aptpkg.get_repo_keys(), REPO_KEYS)
 
+    @patch('salt.modules.aptpkg.__salt__', {'lowpkg.file_dict': MagicMock(return_value=LOWPKG_FILES)})
     def test_file_dict(self):
         '''
         Test - List the files that belong to a package, grouped by package.
         '''
-        mock = MagicMock(return_value=LOWPKG_FILES)
-        with patch.dict(aptpkg.__salt__, {'lowpkg.file_dict': mock}):
-            self.assertEqual(aptpkg.file_dict('wget'), LOWPKG_FILES)
+        assert aptpkg.file_dict('wget') == LOWPKG_FILES
 
+    @patch('salt.modules.aptpkg.__salt__', {
+        'lowpkg.file_list': MagicMock(return_value={'errors': LOWPKG_FILES['errors'],
+                                                    'files': LOWPKG_FILES['packages']['wget']})})
     def test_file_list(self):
         '''
-        Test - List the files that belong to a package.
+        Test 'file_list' function, which is just an alias to the lowpkg 'file_list'
+
         '''
-        files = {
-            'errors': LOWPKG_FILES['errors'],
-            'files': LOWPKG_FILES['packages']['wget'],
-        }
-        mock = MagicMock(return_value=files)
-        with patch.dict(aptpkg.__salt__, {'lowpkg.file_list': mock}):
-            self.assertEqual(aptpkg.file_list('wget'), files)
+        assert aptpkg.file_list('wget') == aptpkg.__salt__['lowpkg.file_list']()
 
+    @patch('salt.modules.aptpkg.__salt__', {'cmd.run_stdout': MagicMock(return_value='wget\t\t\t\t\t\tinstall')})
     def test_get_selections(self):
         '''
         Test - View package state from the dpkg database.
         '''
-        selections = {'install': ['wget']}
-        mock = MagicMock(return_value='wget\t\t\t\t\t\tinstall')
-        with patch.dict(aptpkg.__salt__, {'cmd.run_stdout': mock}):
-            self.assertEqual(aptpkg.get_selections('wget'), selections)
+        assert aptpkg.get_selections('wget') == {'install': ['wget']}
 
+    @patch('salt.modules.aptpkg.__salt__', {'lowpkg.info': MagicMock(return_value=LOWPKG_INFO)})
     def test_info_installed(self):
         '''
         Test - Return the information of the named package(s) installed on the system.
@@ -243,19 +229,72 @@ class AptPkgTestCase(TestCase, LoaderModuleMockMixin):
             if installed['wget'].get(names[name], False):
                 installed['wget'][name] = installed['wget'].pop(names[name])
 
-        mock = MagicMock(return_value=LOWPKG_INFO)
-        with patch.dict(aptpkg.__salt__, {'lowpkg.info': mock}):
-            self.assertEqual(aptpkg.info_installed('wget'), installed)
+        assert aptpkg.info_installed('wget') == installed
+
+    @patch('salt.modules.aptpkg.__salt__', {'lowpkg.info': MagicMock(return_value=LOWPKG_INFO)})
+    def test_info_installed_attr(self):
+        '''
+        Test info_installed 'attr'.
+        This doesn't test 'attr' behaviour per se, since the underlying function is in dpkg.
+        The test should simply not raise exceptions for invalid parameter.
+
+        :return:
+        '''
+        ret = aptpkg.info_installed('emacs', attr='foo,bar')
+        assert isinstance(ret, dict)
+        assert 'wget' in ret
+        assert isinstance(ret['wget'], dict)
+
+        wget_pkg = ret['wget']
+        expected_pkg = {'url': 'http://www.gnu.org/software/wget/',
+                        'packager': 'Ubuntu Developers <ubuntu-devel-discuss@lists.ubuntu.com>', 'name': 'wget',
+                        'install_date': '2016-08-30T22:20:15Z', 'description': 'retrieves files from the web',
+                        'version': '1.15-1ubuntu1.14.04.2', 'architecture': 'amd64', 'group': 'web', 'source': 'wget'}
+        for k in wget_pkg:
+            assert k in expected_pkg
+            assert wget_pkg[k] == expected_pkg[k]
+
+    @patch('salt.modules.aptpkg.__salt__', {'lowpkg.info': MagicMock(return_value=LOWPKG_INFO)})
+    def test_info_installed_all_versions(self):
+        '''
+        Test info_installed 'all_versions'.
+        Since Debian won't return same name packages with the different names,
+        this should just return different structure, backward compatible with
+        the RPM equivalents.
+
+        :return:
+        '''
+        print()
+        ret = aptpkg.info_installed('emacs', all_versions=True)
+        assert isinstance(ret, dict)
+        assert 'wget' in ret
+        assert isinstance(ret['wget'], list)
 
+        pkgs = ret['wget']
+
+        assert len(pkgs) == 1
+        assert isinstance(pkgs[0], dict)
+
+        wget_pkg = pkgs[0]
+        expected_pkg = {'url': 'http://www.gnu.org/software/wget/',
+                        'packager': 'Ubuntu Developers <ubuntu-devel-discuss@lists.ubuntu.com>', 'name': 'wget',
+                        'install_date': '2016-08-30T22:20:15Z', 'description': 'retrieves files from the web',
+                        'version': '1.15-1ubuntu1.14.04.2', 'architecture': 'amd64', 'group': 'web', 'source': 'wget'}
+        for k in wget_pkg:
+            assert k in expected_pkg
+            assert wget_pkg[k] == expected_pkg[k]
+
+    @patch('salt.modules.aptpkg.__salt__', {'cmd.run_stdout': MagicMock(return_value='wget: /usr/bin/wget')})
     def test_owner(self):
         '''
         Test - Return the name of the package that owns the file.
         '''
-        paths = ['/usr/bin/wget']
-        mock = MagicMock(return_value='wget: /usr/bin/wget')
-        with patch.dict(aptpkg.__salt__, {'cmd.run_stdout': mock}):
-            self.assertEqual(aptpkg.owner(*paths), 'wget')
+        assert aptpkg.owner('/usr/bin/wget') == 'wget'
 
+    @patch('salt.utils.pkg.clear_rtag', MagicMock())
+    @patch('salt.modules.aptpkg.__salt__', {'cmd.run_all': MagicMock(return_value={'retcode': 0,
+                                                                                   'stdout': APT_Q_UPDATE}),
+                                            'config.get': MagicMock(return_value=False)})
     def test_refresh_db(self):
         '''
         Test - Updates the APT database to latest packages based upon repositories.
@@ -267,26 +306,20 @@ class AptPkgTestCase(TestCase, LoaderModuleMockMixin):
             'http://security.ubuntu.com trusty-security/main amd64 Packages': True,
             'http://security.ubuntu.com trusty-security/main i386 Packages': True
         }
-        mock = MagicMock(return_value={
-            'retcode': 0,
-            'stdout': APT_Q_UPDATE
-        })
-        with patch('salt.utils.pkg.clear_rtag', MagicMock()):
-            with patch.dict(aptpkg.__salt__, {'cmd.run_all': mock}):
-                self.assertEqual(aptpkg.refresh_db(), refresh_db)
+        assert aptpkg.refresh_db() == refresh_db
 
+    @patch('salt.utils.pkg.clear_rtag', MagicMock())
+    @patch('salt.modules.aptpkg.__salt__', {'cmd.run_all': MagicMock(return_value={'retcode': 0,
+                                                                                   'stdout': APT_Q_UPDATE_ERROR}),
+                                            'config.get': MagicMock(return_value=False)})
     def test_refresh_db_failed(self):
         '''
         Test - Update the APT database using unreachable repositories.
         '''
-        kwargs = {'failhard': True}
-        mock = MagicMock(return_value={
-            'retcode': 0,
-            'stdout': APT_Q_UPDATE_ERROR
-        })
-        with patch('salt.utils.pkg.clear_rtag', MagicMock()):
-            with patch.dict(aptpkg.__salt__, {'cmd.run_all': mock}):
-                self.assertRaises(CommandExecutionError, aptpkg.refresh_db, **kwargs)
+        with pytest.raises(CommandExecutionError) as err:
+            aptpkg.refresh_db(failhard=True)
+        assert 'Error getting repos' in str(err)
+        assert 'http://security.ubuntu.com trusty InRelease, http://security.ubuntu.com trusty Release.gpg' in str(err)
 
     def test_autoremove(self):
         '''
@@ -306,38 +339,26 @@ class AptPkgTestCase(TestCase, LoaderModuleMockMixin):
                 self.assertEqual(aptpkg.autoremove(list_only=True), list())
                 self.assertEqual(aptpkg.autoremove(list_only=True, purge=True), list())
 
+    @patch('salt.modules.aptpkg._uninstall', MagicMock(return_value=UNINSTALL))
     def test_remove(self):
         '''
         Test - Remove packages.
         '''
-        with patch('salt.modules.aptpkg._uninstall',
-                   MagicMock(return_value=UNINSTALL)):
-            self.assertEqual(aptpkg.remove(name='tmux'), UNINSTALL)
+        assert aptpkg.remove(name='tmux') == UNINSTALL
 
+    @patch('salt.modules.aptpkg._uninstall', MagicMock(return_value=UNINSTALL))
     def test_purge(self):
         '''
         Test - Remove packages along with all configuration files.
         '''
-        with patch('salt.modules.aptpkg._uninstall',
-                   MagicMock(return_value=UNINSTALL)):
-            self.assertEqual(aptpkg.purge(name='tmux'), UNINSTALL)
+        assert aptpkg.purge(name='tmux') == UNINSTALL
 
+    @patch('salt.utils.pkg.clear_rtag', MagicMock())
+    @patch('salt.modules.aptpkg.list_pkgs', MagicMock(return_value=UNINSTALL))
+    @patch.multiple(aptpkg, **{'__salt__': {'config.get': MagicMock(return_value=True),
+                                            'cmd.run_all': MagicMock(return_value={'retcode': 0, 'stdout': UPGRADE})}})
     def test_upgrade(self):
         '''
         Test - Upgrades all packages.
         '''
-        with patch('salt.utils.pkg.clear_rtag', MagicMock()):
-            with patch('salt.modules.aptpkg.list_pkgs',
-                       MagicMock(return_value=UNINSTALL)):
-                mock_cmd = MagicMock(return_value={
-                    'retcode': 0,
-                    'stdout': UPGRADE
-                })
-                patch_kwargs = {
-                    '__salt__': {
-                        'config.get': MagicMock(return_value=True),
-                        'cmd.run_all': mock_cmd
-                    }
-                }
-                with patch.multiple(aptpkg, **patch_kwargs):
-                    self.assertEqual(aptpkg.upgrade(), dict())
+        assert aptpkg.upgrade() == {}
diff --git a/tests/unit/modules/test_dpkg.py b/tests/unit/modules/test_dpkg.py
index fcfa7caf77..1acfd89ccf 100644
--- a/tests/unit/modules/test_dpkg.py
+++ b/tests/unit/modules/test_dpkg.py
@@ -25,6 +25,30 @@ class DpkgTestCase(TestCase, LoaderModuleMockMixin):
     '''
     Test cases for salt.modules.dpkg
     '''
+    dselect_pkg = {
+        'emacs': {'priority': 'optional', 'filename': 'pool/main/e/emacs-defaults/emacs_46.1_all.deb',
+                  'description': 'GNU Emacs editor (metapackage)', 'md5sum': '766eb2cee55ba0122dac64c4cea04445',
+                  'sha256': 'd172289b9a1608820eddad85c7ffc15f346a6e755c3120de0f64739c4bbc44ce',
+                  'description-md5': '21fb7da111336097a2378959f6d6e6a8',
+                  'bugs': 'https://bugs.launchpad.net/springfield/+filebug',
+                  'depends': 'emacs24 | emacs24-lucid | emacs24-nox', 'origin': 'Simpsons', 'version': '46.1',
+                  'task': 'ubuntu-usb, edubuntu-usb', 'original-maintainer': 'Homer Simpson <homer@springfield.org>',
+                  'package': 'emacs', 'architecture': 'all', 'size': '1692',
+                  'sha1': '9271bcec53c1f7373902b1e594d9fc0359616407', 'source': 'emacs-defaults',
+                  'maintainer': 'Simpsons Developers <simpsons-devel-discuss@lists.springfield.org>', 'supported': '9m',
+                  'section': 'editors', 'installed-size': '25'}
+    }
+
+    pkgs_info = [
+        {'version': '46.1', 'arch': 'all', 'build_date': '2014-08-07T16:51:48Z', 'install_date_time_t': 1481745778,
+         'section': 'editors', 'description': 'GNU Emacs editor (metapackage)\n GNU Emacs is the extensible '
+                                              'self-documenting text editor.\n This is a metapackage that will always '
+                                              'depend on the latest\n recommended Emacs release.\n',
+         'package': 'emacs', 'source': 'emacs-defaults',
+         'maintainer': 'Simpsons Developers <simpsons-devel-discuss@lists.springfield.org>',
+         'build_date_time_t': 1407430308, 'installed_size': '25', 'install_date': '2016-12-14T20:02:58Z'}
+    ]
+
     def setup_loader_modules(self):
         return {dpkg: {}}
 
@@ -102,3 +126,48 @@ class DpkgTestCase(TestCase, LoaderModuleMockMixin):
                                        'stdout': 'Salt'})
         with patch.dict(dpkg.__salt__, {'cmd.run_all': mock}):
             self.assertEqual(dpkg.file_dict('httpd'), 'Error:  error')
+
+    @patch('salt.modules.dpkg._get_pkg_ds_avail', MagicMock(return_value=dselect_pkg))
+    @patch('salt.modules.dpkg._get_pkg_info', MagicMock(return_value=pkgs_info))
+    @patch('salt.modules.dpkg._get_pkg_license', MagicMock(return_value='BSD v3'))
+    def test_info(self):
+        '''
+        Test info
+        :return:
+        '''
+        ret = dpkg.info('emacs')
+
+        assert isinstance(ret, dict)
+        assert len(ret.keys()) == 1
+        assert 'emacs' in ret
+
+        pkg_data = ret['emacs']
+
+        assert isinstance(pkg_data, dict)
+        for pkg_section in ['section', 'architecture', 'original-maintainer', 'maintainer', 'package', 'installed-size',
+                            'build_date_time_t', 'sha256', 'origin', 'build_date', 'size', 'source', 'version',
+                            'install_date_time_t', 'license', 'priority', 'description', 'md5sum', 'supported',
+                            'filename', 'sha1', 'install_date', 'arch']:
+            assert pkg_section in pkg_data
+
+        assert pkg_data['section'] == 'editors'
+        assert pkg_data['maintainer'] == 'Simpsons Developers <simpsons-devel-discuss@lists.springfield.org>'
+        assert pkg_data['license'] == 'BSD v3'
+
+    @patch('salt.modules.dpkg._get_pkg_ds_avail', MagicMock(return_value=dselect_pkg))
+    @patch('salt.modules.dpkg._get_pkg_info', MagicMock(return_value=pkgs_info))
+    @patch('salt.modules.dpkg._get_pkg_license', MagicMock(return_value='BSD v3'))
+    def test_info_attr(self):
+        '''
+        Test info with 'attr' parameter
+        :return:
+        '''
+        ret = dpkg.info('emacs', attr='arch,license,version')
+        assert isinstance(ret, dict)
+        assert 'emacs' in ret
+        for attr in ['arch', 'license', 'version']:
+            assert attr in ret['emacs']
+
+        assert ret['emacs']['arch'] == 'all'
+        assert ret['emacs']['license'] == 'BSD v3'
+        assert ret['emacs']['version'] == '46.1'
-- 
2.19.1


